<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Rain Drop Rush â€” Save the Plant (Mobile Optimized)</title>
<meta name="apple-mobile-web-app-capable" content="yes">
<style>
  :root{
    --bg1:#9fe6ff; --bg2:#d3f7d8; --panel:rgba(255,255,255,0.85); --accent:#0b6a57;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));-webkit-font-smoothing:antialiased;font-family:Inter,system-ui, -apple-system, 'Segoe UI', Roboto, Arial;display:flex;align-items:center;justify-content:center;padding:12px;}
  #container{width:100%;max-width:940px;display:flex;flex-direction:column;gap:10px;align-items:center;}
  #ui{width:100%;display:flex;justify-content:space-between;align-items:center;gap:10px}
  #score{background:var(--panel);padding:8px 12px;border-radius:10px;font-weight:700;color:#084c3d;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  #thirstBar{flex:1;height:16px;border-radius:12px;background:rgba(0,0,0,0.06);overflow:hidden;border:2px solid rgba(255,255,255,0.25);margin:0 10px}
  #thirstFill{height:100%;width:100%;background:linear-gradient(90deg,#4bd3ff,#2bffb8);transition:width 0.15s linear}
  #byline{background:var(--panel);padding:8px 12px;border-radius:10px;color:#075;font-weight:600;font-style:italic}
  canvas{width:100%;border-radius:12px;display:block;touch-action:none;box-shadow:0 10px 30px rgba(0,0,0,0.12);background:transparent}
  #controls{width:100%;display:flex;justify-content:space-between;align-items:center;margin-top:8px}
  .btn{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:10px;font-weight:700}
  #help{color:#064a3f;font-size:13px}
  /* on-screen arrows for touch */
  #touchLayer{position:relative;width:100%;max-width:940px;display:flex;justify-content:center;align-items:center;margin-top:8px}
  .touchBtn{position:fixed;bottom:22px;width:62px;height:62px;border-radius:50%;background:rgba(11,106,87,0.12);display:flex;align-items:center;justify-content:center;font-size:28px;color:#063f35;user-select:none;z-index:60}
  #leftBtn{left:18px}
  #rightBtn{right:18px}
  #swatHint{position:fixed;right:18px;top:120px;background:var(--panel);padding:8px 10px;border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.08);font-size:12px}
  @media(min-width:720px){ .touchBtn{display:none} #swatHint{display:none} }
</style>
</head>
<body>
<div id="container">
  <div id="ui">
    <div id="score">Score: <span id="scoreVal">0</span></div>
    <div style="display:flex;align-items:center;flex:1">
      <div id="thirstLabel" style="font-size:12px;color:#2b5a4e;margin-right:8px">Thirst</div>
      <div id="thirstBar"><div id="thirstFill"></div></div>
    </div>
    <div id="byline">Game by <span style="font-style:normal">Balaji Gopinath</span></div>
  </div>

  <canvas id="gameCanvas" width="900" height="600" aria-label="Rain Drop Rush game"></canvas>

  <div id="controls">
    <button id="startBtn" class="btn">Start</button>
    <div id="help">Tap left/right â€¢ Tap bugs to swat â€¢ Hold edges to move</div>
    <button id="muteBtn" class="btn">ðŸ”Š</button>
  </div>
</div>

<!-- On-screen touch buttons (mobile) -->
<div id="touchLayer" aria-hidden="true">
  <div id="leftBtn" class="touchBtn">â—€</div>
  <div id="rightBtn" class="touchBtn">â–¶</div>
  <div id="swatHint">Tap bugs to swat</div>
</div>

<script>
/* Rain Drop Rush â€” Mobile-optimized single-file
 - Use devicePixelRatio for crisp canvas
 - Time-based game loop using dt in seconds (pixels per second)
 - Expects an image file in repo root named "monstera.png"
*/

// ---------- configuration ----------
const IMG_SRC = 'monstera.png'; // change if your filename differs
const CANVAS_BASE_W = 900, CANVAS_BASE_H = 600; // logical coordinate system
// speeds (pixels per second)
const DROP_INITIAL_VY = 180; // px/s starting vertical speed
const DROP_GRAVITY = 600; // px/s^2
const POT_SPEED = 360; // px/s when holding left/right
const DROP_SPAWN_INTERVAL = 0.75; // seconds between drops (time-based)
const BUG_SPAWN_INTERVAL = 5.0; // seconds between bug spawns

// ---------- globals ----------
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, window.devicePixelRatio || 1);
let internalW = CANVAS_BASE_W, internalH = CANVAS_BASE_H;

let lastTime = null;
let accSpawn = 0;
let accBug = 0;
let running = false;
let score = 0;
let thirst = 100;
let health = 100;
let speedMultiplier = 1.0; // difficulty scale
let drops = [], bugs = [], particles = [];
let leftHeld = false, rightHeld = false;
let pot = { x: internalW/2 - 55, y: internalH - 120, w: 110, h: 26 };
let monstera = new Image();
monstera.src = IMG_SRC;
let audioCtx = null, unlockedAudio=false;
let muted = false;

// UI refs
const scoreEl = document.getElementById('scoreVal');
const thirstFill = document.getElementById('thirstFill');
const startBtn = document.getElementById('startBtn');
const muteBtn = document.getElementById('muteBtn');
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');

// ---------- helpers ----------
function resizeCanvasToDisplay() {
  // canvas internal pixel size
  DPR = Math.max(1, window.devicePixelRatio || 1);
  // keep same internal coordinate system (900x600) but scale by DPR
  canvas.width = internalW * DPR;
  canvas.height = internalH * DPR;
  canvas.style.width = Math.min(window.innerWidth - 24, internalW) + 'px';
  canvas.style.height = (canvas.height / canvas.width) * parseFloat(canvas.style.width) + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // scale drawing operations
}
resizeCanvasToDisplay();
window.addEventListener('resize', resizeCanvasToDisplay);

// dt-based audio beep
function beep(freq=880, type='sine', duration=0.08, vol=0.06){
  if(muted) return;
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if(audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + duration);
  } catch(e){}
}

// unlock audio for iOS: call on first user gesture
function unlockAudioOnUserGesture(){
  if(unlockedAudio) return;
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = audioCtx.createBuffer(1,1,22050);
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start(0);
    unlockedAudio = true;
  } catch(e){}
}

// ---------- input ----------
window.addEventListener('keydown', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') leftHeld = true;
  if(e.key === 'ArrowRight' || e.key === 'd') rightHeld = true;
});
window.addEventListener('keyup', (e)=>{
  if(e.key === 'ArrowLeft' || e.key === 'a') leftHeld = false;
  if(e.key === 'ArrowRight' || e.key === 'd') rightHeld = false;
});

// touch: tap left/right halves
canvas.addEventListener('touchstart', (ev)=>{
  ev.preventDefault();
  unlockAudioOnUserGesture();
  for(const t of ev.changedTouches){
    const rect = canvas.getBoundingClientRect();
    const x = t.clientX - rect.left;
    if(x < rect.width * 0.4) leftHeld = true;
    else if(x > rect.width * 0.6) rightHeld = true;
    else {
      // center tap -> attempt swat bug
      const cx = (x / rect.width) * internalW;
      const cy = ( (t.clientY - rect.top) / rect.height ) * internalH;
      // check for bugs
      for(let i=bugs.length-1;i>=0;i--){
        const b = bugs[i];
        const d = Math.hypot(b.x - cx, b.y - cy);
        if(d < 36){
          bugs.splice(i,1);
          score += 10;
          particles.push({x:cx,y:cy,r:8,life:0.5,color:'rgba(255,220,0,0.95)'});
          beep(720,'square',0.06,0.08);
          break;
        }
      }
    }
  }
}, {passive:false});
canvas.addEventListener('touchend', (ev)=>{ ev.preventDefault(); leftHeld=false; rightHeld=false; }, {passive:false});

// on-screen arrows
leftBtn.addEventListener('touchstart', (e)=>{ unlockAudioOnUserGesture(); leftHeld=true; e.preventDefault(); }, {passive:false});
leftBtn.addEventListener('touchend', ()=>{ leftHeld=false; });
rightBtn.addEventListener('touchstart', (e)=>{ unlockAudioOnUserGesture(); rightHeld=true; e.preventDefault(); }, {passive:false});
rightBtn.addEventListener('touchend', ()=>{ rightHeld=false; });

// mouse click for swat
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const cx = ((e.clientX - rect.left) / rect.width) * internalW;
  const cy = ((e.clientY - rect.top) / rect.height) * internalH;
  for(let i=bugs.length-1;i>=0;i--){
    const b = bugs[i];
    const d = Math.hypot(b.x - cx, b.y - cy);
    if(d < 36){
      bugs.splice(i,1);
      score += 10;
      particles.push({x:cx,y:cy,r:8,life:0.5,color:'rgba(255,220,0,0.95)'});
      beep(720,'square',0.06,0.08);
      return;
    }
  }
});

// ---------- game object factories ----------
function spawnDrop(){
  const x = 40 + Math.random() * (internalW - 80);
  const r = 6 + Math.random()*5;
  const vy = DROP_INITIAL_VY + Math.random()*60;
  const vx = (Math.random()-0.5) * 80 * (0.3 + Math.random()*0.7) * (Math.random()<0.25 ? 1.5 : 1); // slight wind
  drops.push({x:x, y:-r, r:r, vx: vx, vy: vy});
}
function spawnBug(){
  const fromLeft = Math.random()<0.5;
  const y = internalH - 240 + Math.random()*80;
  const x = fromLeft ? -20 : internalW + 20;
  const vx = (fromLeft ? 1 : -1) * (80 + Math.random()*80) * (1 + speedMultiplier*0.12);
  bugs.push({x:x, y:y, vx: vx});
}

// ---------- update & draw ----------
function updateAndDraw(dt){
  // dt in seconds
  if(running){
    // player movement
    if(leftHeld) pot.x -= POT_SPEED * dt;
    if(rightHeld) pot.x += POT_SPEED * dt;
    // clamp
    pot.x = Math.max(6, Math.min(internalW - pot.w - 6, pot.x));

    // spawn timers
    accSpawn += dt;
    accBug += dt;
    const spawnInterval = Math.max(0.25, DROP_SPAWN_INTERVAL / (1 + (speedMultiplier-1)*0.7));
    if(accSpawn > spawnInterval){ spawnDrop(); accSpawn = 0; }
    if(accBug > BUG_SPAWN_INTERVAL){ spawnBug(); accBug = 0; }

    // update drops (physics)
    for(let i=drops.length-1;i>=0;i--){
      const d = drops[i];
      d.vy += DROP_GRAVITY * dt * (0.9 + speedMultiplier*0.04);
      d.x += d.vx * dt * (0.9 + speedMultiplier*0.03);
      d.y += d.vy * dt;

      // catch check (pot rectangle)
      if(d.y + d.r > pot.y && d.y - d.r < pot.y + pot.h && d.x > pot.x && d.x < pot.x + pot.w){
        drops.splice(i,1);
        score += 5;
        thirst = Math.min(100, thirst + 6);
        speedMultiplier += 0.015; // increase difficulty gradually
        particles.push({x:d.x, y:pot.y, r:d.r*1.8, life:0.4, color:'rgba(90,210,255,0.95)'});
        beep(880,'sine',0.04,0.06);
        continue;
      }
      // missed
      if(d.y > internalH + 30){
        drops.splice(i,1);
        thirst -= 8;
        health -= 2;
        particles.push({x:d.x,y:internalH-80,r:d.r*1.6,life:0.35,color:'rgba(180,100,80,0.7)'});
        beep(240,'sawtooth',0.06,0.06);
      }
    }

    // update bugs
    for(let i=bugs.length-1;i>=0;i--){
      const b = bugs[i];
      b.x += b.vx * dt;
      const leafX = internalW/2, leafY = internalH - 220;
      const dleaf = Math.hypot(b.x - leafX, b.y - leafY);
      if(dleaf < 60){
        bugs.splice(i,1);
        health -= 12;
        thirst -= 6;
        particles.push({x:b.x,y:b.y,r:10,life:0.6,color:'rgba(200,60,60,0.95)'});
        beep(260,'triangle',0.08,0.08);
        continue;
      }
      if(b.x < -80 || b.x > internalW + 80) bugs.splice(i,1);
    }

    // update particles
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.life -= dt;
      if(p.life <= 0) particles.splice(i,1);
      else p.r *= (1 - Math.min(0.08, dt*3));
    }

    // passive thirst drain
    thirst -= 0.6 * dt * (1 + (speedMultiplier-1)*0.15);
    thirst = Math.max(0, thirst);
    if(thirst <= 0 || health <= 0){
      running = false;
      startBtn.textContent = 'Game Over â€” Restart';
      beep(140,'sine',0.6,0.12);
    }

    // score/time UI
    scoreEl.textContent = Math.floor(score);
    thirstFill.style.width = Math.max(0, Math.floor(thirst)) + '%';
    // color shift
    const g = Math.floor(115 + (thirst/100)*120);
    const bcol = Math.floor(150 + (thirst/100)*100);
    thirstFill.style.background = `linear-gradient(90deg,rgb(75,211,255), rgb(${Math.min(255,g)},${Math.min(255,bcol)},180))`;
  }

  // draw
  ctx.clearRect(0,0,internalW,internalH);

  // background
  const g = ctx.createLinearGradient(0,0,0,internalH);
  g.addColorStop(0,'#9fe6ff');
  g.addColorStop(1,'#d3f7d8');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,internalW,internalH);

  // drops (behind plant)
  for(const d of drops){
    ctx.beginPath();
    const grd = ctx.createRadialGradient(d.x, d.y, 1, d.x, d.y, d.r);
    grd.addColorStop(0,'rgba(255,255,255,0.95)');
    grd.addColorStop(0.2,'rgba(140,220,255,0.98)');
    grd.addColorStop(1,'rgba(40,160,220,0.7)');
    ctx.fillStyle = grd;
    ctx.ellipse(d.x, d.y, d.r*0.6, d.r, 0, 0, Math.PI*2);
    ctx.fill();
  }

  // pot & soil
  ctx.fillStyle = '#6a3b20';
  ctx.fillRect(pot.x, pot.y, pot.w, pot.h);
  ctx.fillStyle = '#3f2715';
  ctx.fillRect(pot.x + 8, pot.y - 12, pot.w - 16, 12);

  // plant image
  const growth = Math.min(1.0, 0.45 + (score / 300));
  const leafX = internalW/2, leafY = internalH - 220;
  const leafW = 320 * growth, leafH = 220 * growth;
  ctx.save();
  ctx.translate(leafX - leafW/2, leafY - leafH/2);
  const sway = Math.sin((performance.now()/800))*3 * (0.5 + growth*0.5);
  ctx.rotate(sway * Math.PI/180);
  // draw image; if image not loaded yet, draw placeholder
  if(monstera.complete && monstera.naturalWidth){
    ctx.drawImage(monstera, 0, 0, leafW, leafH);
  } else {
    ctx.fillStyle = '#7ecf9a';
    ctx.fillRect(0,0,leafW,leafH);
  }
  // wilting overlay
  if(thirst < 30 || health < 30){
    const alpha = Math.min(0.7, (30 - Math.min(thirst, health)) / 40);
    ctx.fillStyle = 'rgba(120,60,20,'+alpha+')';
    ctx.fillRect(0,0,leafW,leafH);
    ctx.fillStyle = 'rgba(80,80,80,'+ (alpha*0.25) +')';
    ctx.fillRect(0,0,leafW,leafH);
  }
  ctx.restore();

  // bugs
  for(const b of bugs){
    ctx.beginPath();
    ctx.fillStyle = '#222';
    ctx.ellipse(b.x, b.y, 10, 8, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#222';
    ctx.fillRect(b.x-5, b.y-12, 10, 3);
  }

  // particles
  for(const p of particles){
    ctx.beginPath();
    ctx.globalAlpha = Math.max(0.15, p.life / 0.6);
    ctx.fillStyle = p.color || 'rgba(255,255,255,0.9)';
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // health hearts
  for(let i=0;i<5;i++){
    const hx = 14 + i*22, hy = 12;
    ctx.beginPath();
    ctx.fillStyle = i < Math.ceil(health/20) ? '#ff6666' : 'rgba(255,255,255,0.25)';
    ctx.arc(hx+4, hy+6, 5, 0, Math.PI*2);
    ctx.arc(hx+10, hy+6, 5, 0, Math.PI*2);
    ctx.moveTo(hx+1, hy+10);
    ctx.lineTo(hx+14, hy+10);
    ctx.fill();
  }
}

// ---------- main loop (dt in seconds) ----------
function mainLoop(timestamp){
  if(lastTime === null) lastTime = timestamp;
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000); // clamp dt to avoid huge jumps
  lastTime = timestamp;
  updateAndDraw(dt);
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

// ---------- controls ----------
startBtn.addEventListener('click', ()=>{
  unlockAudioOnUserGesture();
  if(!running){
    // reset
    drops = []; bugs = []; particles = [];
    accSpawn = accBug = 0;
    score = 0; thirst = 100; health = 100; speedMultiplier = 1;
    pot.x = internalW/2 - pot.w/2;
    running = true;
    startBtn.textContent = 'Running...';
    beep(960,'sine',0.06,0.06);
  } else {
    running = false;
    startBtn.textContent = 'Paused â€” Resume';
  }
});

muteBtn.addEventListener('click', ()=>{
  muted = !muted;
  muteBtn.textContent = muted ? 'ðŸ”ˆ' : 'ðŸ”Š';
  if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
});

// unlock audio helper for iOS
function unlockAudioOnUserGesture(){
  if(unlockedAudio) return;
  try {
    if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const buffer = audioCtx.createBuffer(1, 1, 22050);
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.connect(audioCtx.destination);
    src.start(0);
    unlockedAudio = true;
  } catch(e){}
}

// pause when tab hidden
document.addEventListener('visibilitychange', ()=>{ if(document.hidden) running=false; });

// ensure canvas resolution is correct if DPR changed
setInterval(()=>{ if(Math.abs((window.devicePixelRatio||1) - DPR) > 0.2) resizeCanvasToDisplay(); }, 1000);

</script>
</body>
</html>
